// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bytescan

import (
	"bufio"
	"io"
)

const maxConsecutiveEmptyReads = 100

type Scanner struct {
	buf        []byte
	split      bufio.SplitFunc
	token      []byte // Last token returned by split.
	start      int    // First non-processed byte in buf.
	end        int
	err        error // Sticky error.
	empties    int   // Count of successive empty tokens.
	scanCalled bool  // Scan has been called; buffer is in use.
	done       bool  // Scan has finished.
}

func NewScanner(buf []byte) *Scanner {
	return &Scanner{
		buf:   buf,
		split: bufio.ScanLines,
		end:   len(buf),
	}
}

// Err returns the first non-EOF error that was encountered by the Scanner.
func (s *Scanner) Err() error {
	if s.err == io.EOF {
		return nil
	}
	return s.err
}

// Bytes returns the most recent token generated by a call to Scan.
// The underlying array will be a slice of the input data, and is safe
// to retain as long as data is retained.
func (s *Scanner) Bytes() []byte {
	return s.token
}

// Text returns the most recent token generated by a call to Scan
// as a newly allocated string holding its bytes.
func (s *Scanner) Text() string {
	return string(s.token)
}

// Scan advances the Scanner to the next token, which will then be
// available through the Bytes or Text method. It returns false when the
// scan stops, either by reaching the end of the input or an error.
// After Scan returns false, the Err method will return any error that
// occurred during scanning, except that if it was io.EOF, Err
// will return nil.
// Scan panics if the split function returns too many empty
// tokens without advancing the input. This is a common error mode for
// scanners.
func (s *Scanner) Scan() bool {
	if s.done {
		return false
	}

	if !s.scanCalled {
		s.scanCalled = true
	}

	// Loop until we have a token.
	for {
		// See if we can get a token with what we already have.
		// If we've run out of data but have an error, give the split function
		// a chance to recover any remaining, possibly empty token.
		if s.end > s.start || s.err != nil {
			advance, token, err := s.split(s.buf[s.start:], s.err != nil)
			if err != nil {
				if err == bufio.ErrFinalToken {
					s.token = token
					s.done = true
					return true
				}

				s.setErr(err)
				return false
			}

			if !s.advance(advance) {
				return false
			}

			s.token = token

			if token != nil {
				if s.err == nil || advance > 0 {
					s.empties = 0

				} else {
					// Returning tokens not advancing input at EOF.
					s.empties++
					if s.empties > maxConsecutiveEmptyReads {
						panic("bufio.Scan: too many empty tokens without progressing")
					}
				}

				return true
			}
		}

		if s.err != nil {
			return false
		}

		// We cannot generate a token with what we are holding.
		// If we've already hit EOF or an I/O error, we are done.
		s.setErr(io.EOF)
	}
}

// advance consumes n bytes of the buffer. It reports whether the advance was legal.
func (s *Scanner) advance(n int) bool {
	if n < 0 {
		s.setErr(bufio.ErrNegativeAdvance)
		return false
	}
	if n > s.end-s.start {
		s.setErr(bufio.ErrAdvanceTooFar)
		return false
	}
	s.start += n
	return true
}

// setErr records the first error encountered.
func (s *Scanner) setErr(err error) {
	if s.err == nil || s.err == io.EOF {
		s.err = err
	}
}

// Split sets the split function for the Scanner.
// The default split function is ScanLines.
//
// Split panics if it is called after scanning has started.
func (s *Scanner) Split(split bufio.SplitFunc) {
	if s.scanCalled {
		panic("Split called after Scan")
	}
	s.split = split
}
